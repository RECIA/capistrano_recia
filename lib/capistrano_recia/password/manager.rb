# encoding: utf-8
class Capistrano::Password::Manager
  
  require 'yaml'
  require 'encrypted_strings'
  require 'keepass/password'
  
  
  # constructor must determine the path to the save file.
  # if we need to change the keepass regexp, the second parameter is used for it (default [S]20)
  def initialize(file_path, keepass = "[S]{20}")
    @file_path = file_path
    @salt = "recia_password"
    @keepass_regex = keepass
  end
  
  # to use only in a secure context (batch, admins who should know the pass)
  def live_uncorrupt(save_key)
    pass = nil
    # load yaml file
    yaml = load_file
    # if yaml file contains informations
    if yaml and yaml.has_key? save_key
      # get the password
      pass = yaml[save_key]["password"]
    end

    # decrypt the password
    if pass
      pass = pass.decrypt(:symmetric, :password => @salt)
    end
    
    # return password
    return pass
  end
  
  # permet de savoir si le mot de passe est corrompu
  def is_corrupted?(save_key)
    # load yaml file
    yaml = load_file
    if yaml and yaml.has_key? save_key
      # check if password is corrupted
      corrupt = yaml[save_key]["corrupt"]
      if corrupt.to_s == "true"
        return true
      end
    end
    
    return false
  end
  
  # permet de récupérer les mots de passe corrompus
  def corrupted()
    list = Array.new
    
    yaml = load_file
    
    yaml.keys.each do |key|
      if is_corrupted? key
        list.push key
      end
    end
    
    list
  end
  
  # permet de récupérer un mot de passe si sa clé de sauvegarde est enregistré, sinon retourne nil
  def corrupt(save_key)
    # get passwd
    pass = live_uncorrupt save_key
    
    # load yaml file
    yaml = load_file
    
    # if yaml file contains informations
    if yaml and pass
      # set password to corrupted
      yaml[save_key]["corrupt"] = true

      # save the information of corruption to the file
      File.open(@file_path, "w") do |io|
        io.write(yaml.to_yaml)
        io.close
      end
    end

    # return password
    return pass
  end
  
  # permet de générer un mot de passe.
  # le premier paramètre indique si nous devons sauvegarder ou non le mot de passe (nil ou "" aucune sauvegarde)
  # le deuxième paramètre est celui des options de keepass.
  def generate(save_key="")
    
    # generate a password without lookalikes (l, I, !, ...)
    pass = KeePass::Password.generate(@keepass_regex, :remove_lookalikes => true)
    
    # crypt the password
    enc_pass = pass.encrypt(:symmetric, :password => @salt)
    enc_pass.send :remove_instance_variable, :@cipher
    
    # if a save key is passed
    if save_key and not save_key.empty?
      # load yaml file
      yaml = load_file
      yaml[save_key] = Hash.new if not yaml.has_key? save_key
      # add password to file
      yaml[save_key]["password"] = enc_pass
      yaml[save_key]["corrupt"] = false
      # save file
      File.open(@file_path, "w") do |io|
        io.write(yaml.to_yaml)
        io.close
      end
    end
    
    return pass, enc_pass
    
  end
  
  # regenerate all corrupted password. and return all the password which are regenerated by keys
  def securize()
    
    securized = Hash.new
    
    # for each corrupted passwd
    corrupted.each do |key|
      securized[key] = Hash.new
      securized[key]['old'] = corrupt(key)
      securized[key]['new'], crypted = generate(key)
    end
    
    securized
  end
  
  private
  def load_file()
    yaml = Hash.new
    yaml = YAML::load_file(@file_path) if File.exists? @file_path
    yaml
  end
end